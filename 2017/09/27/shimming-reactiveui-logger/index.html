<!DOCTYPE html>
<html>
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>Shimming ReactiveUI's Log&lt;T&gt;() To Support ASPNet's ILogger&lt;T&gt; - Roman Vaughan</title>

  <!-- Boostrap v4 -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" integrity="sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M" crossorigin="anonymous">
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/js/bootstrap.min.js" integrity="sha384-h0AbiXch4ZDo7tp9hKZ4TsHbi047NrKGLO3SEJAg45jXxnGIfYzk4Si90RDIqNm1" crossorigin="anonymous"></script>

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

  <!-- Pygments code highlighting -->
  <link rel="stylesheet" href=" /css/pygments-vs.css">

  <link rel="stylesheet" href=" /css/uikit.css">
  <link rel="stylesheet" href=" /css/main.css">
</head>
<body>
  
  <div class="container">
    
  <h1><a href="/"><img src="/assets/images/emblem.svg" /></a> Shimming ReactiveUI's Log&lt;T&gt;() To Support ASPNet's ILogger&lt;T&gt;</h1>
  <div class="content">
    <p>Picking up Xamarin app development again after some time and decided to tackle the world of Reactive programming that I fell in love with from when I was building Angular2 web apps using reactive extensions.</p>
<p>Having recently developed server side with ASP.Net Core, I got use to using <code>Ilogger&lt;T&gt;</code> from <code>Microsoft.Extensions.Logging.Abstractions</code>. Was quite handy having a consistant <code>ILogger</code> interface everywhere that was immediately compatable with many 3rd party loggers (NLog, Serilog, et al) and even built some libraries of my own that use it that aren't solely intended for ASP.Net. </p>
<p>Whilst picking up <a href="https://reactiveui.net/">ReactiveUI</a>, they provide their own Service Locator inside of <a href="https://github.com/reactiveui/splat">Splat</a> and provide their own logging classes that aren't directly compatable with <code>ILogger&lt;T&gt;</code> (that I wasn't ready to let go of).</p>
<p><a href="https://reactiveui.net/docs/handbook/logging/">ReactiveUI's Handbook</a> instructs developers to add <code>IEnableLogging</code> to their classes they wish to log from. And by doing so, they gain access to <code>this.Log()</code> thanks the extension method:</p>
<pre class="highlight"><code class="language-C#">public static IFullLogger Log&lt;T&gt;(this T This) where T : IEnableLogger { /* ... */ }</code></pre>


<p>This was done so that your class name (through accessing <code>T</code>) would be included in the logger's output to help keep track of where the log was issued. </p>
<p>Seeing how this was done similarly to <code>ILogger&lt;T&gt;</code> which is really just <code>ILogger</code>. I wanted to bridge the gap by implementing ASP.Net's ILogger<T> and ReactiveUI's Splat logging. Which first involes implementing ILogger<T> </p>
<pre class="highlight"><code class="language-C#">public class ReactiveLogger&lt;TClass&gt; : ILogger&lt;TClass&gt;
{
    public IDisposable BeginScope&lt;TState&gt;(TState state)
    {
        throw new NotImplementedException();
    }

    public bool IsEnabled(LogLevel logLevel)
    {
        throw new NotImplementedException();
    }

    public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func&lt;TState, Exception, string&gt; formatter)
    {        
        throw new NotImplementedException();   
    }
}</code></pre>


<p>Taking a peek into how <code>Microsoft.Extensions.Logging.Console</code> processes <code>public void Log&lt;TState&gt;( ... )</code> I started out by checking <code>IsEnabled()</code>, followed by null-checking <code>formatter</code> and then creating our error message by the supplied <code>formatter</code>, <code>state</code> and <code>extenction</code> parameters.</p>
<pre class="highlight"><code class="language-C#">    if (!IsEnabled(logLevel))
        return;
    if(formatter == null)
        throw new ArgumentNullException(nameof(formatter));

    var message = formatter(state, exception);

    if (string.IsNullOrEmpty(message) &amp;&amp; exception == null)
        return;</code></pre>


<p>You may have noticed a lack of <code>IEnableLogging</code> interface on <code>ReactiveLogger</code>. That's because the logic behind the <code>Log&lt;T&gt;()</code> extension method uses the name of the invoking class. In this case, it'd end up always being <code>ReactiveLogger</code>. </p>
<p>Not very helpful if there's dozens of classes being provided with this logger...</p>
<p>Digging into Splat's <code>ILogManager</code> (which gets invoked on behalf of <code>Log&lt;T&gt;()</code>) it retreives a memory-cached <code>IFullLogger</code> initialised with the name of the invoking class. </p>
<p>So lets copy this bahaviour</p>
<pre class="highlight"><code class="language-C#">    // Get Splat's ILogManager
    var factory = (Splat.ILogManager)Splat.Locator.Current.GetService(typeof(Splat.ILogManager))
        ?? throw new Exception($&quot;{nameof(Splat.ILogManager)} was not found. Please ensure your dependency resolver is configured correctly.&quot;);

    // Get a logger to reprecent our TClass
    var logger = factory.GetLogger(typeof(TClass));</code></pre>


<p>What's <code>Splat.Locator.Current</code> you ask? It's ReactiveUI's prefered method of getting services required throughout your application without tightly coupling everyhting. </p>
<blockquote>
<p><strong>Note:</strong> You're welcome to replace this, but make sure you're populating services requried by ReactiveUI</p>
</blockquote>
<p>We're asking Splat's <code>ILogManager</code> to provide us with a <code>IFullLogger</code> (in the same way <code>Log&lt;T&gt;()</code> does), passing in the the target class's type provided through templating.</p>
<p>All that's left is to invoke the correct logginer method.</p>
<pre class="highlight"><code class="language-C#">    switch (logLevel)
    {
        case LogLevel.Trace:
            // This is very verbose and can be considered equally annoying as LogLevel.Debug in this case.
        case LogLevel.Debug:
            if (exception != null)
                logger.DebugException($&quot;[{eventId.Id}]: {message}&quot;, exception);
            else
                logger.Debug($&quot;[{eventId.Id}]: {message}&quot;);
            break;
        case LogLevel.Information:
            if (exception != null)
                logger.InfoException($&quot;[{eventId.Id}]: {message}&quot;, exception);
            else
                logger.Info($&quot;[{eventId.Id}]: {message}&quot;);
            break;
        case LogLevel.Warning:
            if (exception != null)
                logger.WarnException($&quot;[{eventId.Id}]: {message}&quot;, exception);
            else
                logger.Warn($&quot;[{eventId.Id}]: {message}&quot;);
            break;
        case LogLevel.Error:
            if (exception != null)
                logger.ErrorException($&quot;[{eventId.Id}]: {message}&quot;, exception);
            else
                logger.Error($&quot;[{eventId.Id}]: {message}&quot;);
            break;
        case LogLevel.Critical:
            if (exception != null)
                logger.FatalException($&quot;[{eventId.Id}]: {message}&quot;, exception);
            else
                logger.Fatal($&quot;[{eventId.Id}]: {message}&quot;);
            break;
        case LogLevel.None:
            break;
    }</code></pre>


<p>Where We call the appropiate logging methods in <code>IFullLogger</code> based on our <code>logLevel</code>, if our <code>exception</code> is null and the output of the formatted message. </p>
<h2 id="the-completed-reactivelogger"><a class="toclink" href="#the-completed-reactivelogger">The Completed ReactiveLogger</a></h2>
<pre class="highlight"><code class="language-C#">public class ReactiveLogger&lt;TClass&gt; : ILogger&lt;TClass&gt;
{
    public IDisposable BeginScope&lt;TState&gt;(TState state)
    {
        // Scopes haven't been considered yet and I'll update this article when I need it. 
        throw new NotImplementedException();
    }

    public bool IsEnabled(LogLevel logLevel)
    {
        return true; // Up too you on how you decide to disable logging
    }

    public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func&lt;TState, Exception, string&gt; formatter)
    {
        if (!IsEnabled(logLevel))
            return;
        if(formatter == null)
            throw new ArgumentNullException(nameof(formatter));

        var message = formatter(state, exception);

        if (string.IsNullOrEmpty(message) &amp;&amp; exception == null)
            return;

        // Get Splat's ILogManager
        var factory = (Splat.ILogManager)Splat.Locator.Current.GetService(typeof(Splat.ILogManager))
            ?? throw new Exception($&quot;{nameof(Splat.ILogManager)} was not found. Please ensure your dependency resolver is configured correctly.&quot;);

        // Get a logger to reprecent our TClass
        var logger = factory.GetLogger(typeof(TClass));

        switch (logLevel)
        {
            case LogLevel.Trace:
            case LogLevel.Debug:
                if (exception != null)
                    logger.DebugException($&quot;[{eventId.Id}]: {message}&quot;, exception);
                else
                    logger.Debug($&quot;[{eventId.Id}]: {message}&quot;);
                break;
            case LogLevel.Information:
                if (exception != null)
                    logger.InfoException($&quot;[{eventId.Id}]: {message}&quot;, exception);
                else
                    logger.Info($&quot;[{eventId.Id}]: {message}&quot;);
                break;
            case LogLevel.Warning:
                if (exception != null)
                    logger.WarnException($&quot;[{eventId.Id}]: {message}&quot;, exception);
                else
                    logger.Warn($&quot;[{eventId.Id}]: {message}&quot;);
                break;
            case LogLevel.Error:
                if (exception != null)
                    logger.ErrorException($&quot;[{eventId.Id}]: {message}&quot;, exception);
                else
                    logger.Error($&quot;[{eventId.Id}]: {message}&quot;);
                break;
            case LogLevel.Critical:
                if (exception != null)
                    logger.FatalException($&quot;[{eventId.Id}]: {message}&quot;, exception);
                else
                    logger.Fatal($&quot;[{eventId.Id}]: {message}&quot;);
                break;
            case LogLevel.None:
                break;
        }
    }
}</code></pre>


<h2 id="bootstrapping-splats-service-locator"><a class="toclink" href="#bootstrapping-splats-service-locator">Bootstrapping Splat's Service Locator</a></h2>
<p>When it comes to bootstrapping Splat's service locator, it gets a little too verbose as you're forced to register multiple logger types:</p>
<pre class="highlight"><code class="language-C#">    Locator.CurrentMutable.Register&lt;Microsoft.Extensions.Logging.ILogger&lt;MyService&gt;&gt;(() =&gt; new ReactiveLogger&lt;MyService&gt;());
    Locator.CurrentMutable.Register&lt;Microsoft.Extensions.Logging.ILogger&lt;MyotherService&gt;&gt;(() =&gt; new ReactiveLogger&lt;MyOtherService&gt;());
    // ...</code></pre>


<p>Time to make life a little easier (and reading on your eyes) by using extension methods!</p>
<pre class="highlight"><code class="language-C#">public static class SplatLocatorExtensions
{
    public static Splat.IMutableDependencyResolver RegisterLogger(this Splat.IMutableDependencyResolver services, Type type)
    {
        // Turn ReactiveLogger&lt;&gt; into ReactiveLogger&lt;type&gt;
        var genericReactiveLogger = typeof(ReactiveLogger&lt;&gt;).MakeGenericType(type);
        // Turn ILogger&lt;&gt; into ILogger&lt;type&gt;
        var genericLogger = typeof(ILogger&lt;&gt;).MakeGenericType(type);

        // Register it!
        services.Register(() =&gt; Activator.CreateInstance(genericReactiveLogger), genericLogger);
        return services;
    }

    public static Splat.IMutableDependencyResolver RegisterLogger&lt;TType&gt;(this Splat.IMutableDependencyResolver services)
    {
        // Much simpler as we're dealing with templated types rather than `Type` parameters.
        services.Register(() =&gt; new ReactiveLogger&lt;TType&gt;(), typeof(ILogger&lt;TType&gt;));
        return services;
    }
}</code></pre>


<p>This allows us to quickly register logging for services that need ILogger<T> like this:</p>
<pre class="highlight"><code class="language-C#">    Locator.CurrentMutable.RegisterLogger&lt;MyService&gt;()
                          .RegisterLogger&lt;MyOtherService&gt;()
                          // ...</code></pre>


<p>This allows for us to easily use ASP.Net's <code>ILogger&lt;T&gt;</code> in our Xamarin app when using ReactiveUI as our reactive framework.</p>
  </div>
  <hr>

  </div>
  <footer class="container text-center">
  
<button type="button" class="top btn btn-outline-dark" onclick="window.scrollTo(0, 0)">
  <i class="fa  fa-chevron-up" aria-hidden="true"></i>
  Top
</button>
<div class="contact">
    <a href="https://twitter.com/NZSmartie"><i class="fa fa-twitter" aria-hidden="true"></i><span class="sr-only">My Twitter</span></a>
    <a href="https://github.com/NZSmartie"><i class="fa fa-github" aria-hidden="true"></i><span class="sr-only">My Github</span></a>
    <a href="https://keybase.io/nzsmartie"><i class="fa fa-keybase" aria-hidden="true"></i><span class="sr-only">My Keybase</span></a>
    <a href="https://hackaday.io/NZSmartie"><i class="fa fa-hackaday" aria-hidden="true"></i><span class="sr-only">My Hack A Day I O Profile</span></a>
</div>

    <p class="meta text-right">
      Proudly built with <a href="https://getstatik.com/">Statik</a>
      <br />
      and hosted on <a href="https://help.github.com/articles/what-is-github-pages/">GitHub Pages</a>
    </p>
    

  </footer>
</body>
</html>